<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>认识复杂度与简单排序 | K.island ✨</title>
    <meta name="description" content="K.'s island">
    <link rel="stylesheet" href="/assets/style.019f39fc.css">
    <link rel="modulepreload" href="/assets/Home.7f051d33.js">
    <link rel="modulepreload" href="/assets/app.108cc30f.js">
    <link rel="modulepreload" href="/assets/algorithm_summary_complexity.md.d85a1d14.lean.js">
    <link rel="modulepreload" href="/assets/app.108cc30f.js">
    <link rel="icon" href="/favicon.ico" sizes="64x64">
    <link rel="apple-touch-icon-precomposed" href="/favicon.ico" sizes="64x64">
    <link rel="msapplication-square64x64logo" href="/favicon.ico" sizes="64x64">
    <meta name="twitter:title" content="认识复杂度与简单排序 | K.island ✨">
    <meta property="og:title" content="认识复杂度与简单排序 | K.island ✨">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="K.island ✨, back to home" data-v-675d8756 data-v-4a583abe><!----> K.island ✨</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>Home <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/mood/index" data-v-b8818f8c>Mood <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/knowledge/index" data-v-b8818f8c>Knowledge <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/interview/index" data-v-b8818f8c>Interview <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/algorithm/index" data-v-b8818f8c>Algorithm <!----></a></div></div><!--]--><!----><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://github.com/suressk" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>Home <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/mood/index" data-v-b8818f8c>Mood <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/knowledge/index" data-v-b8818f8c>Knowledge <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/interview/index" data-v-b8818f8c>Interview <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/algorithm/index" data-v-b8818f8c>Algorithm <!----></a></div></div><!--]--><!----><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://github.com/suressk" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><p class="sidebar-link-item">Introduction</p><!----></li><li class="sidebar-link"><p class="sidebar-link-item">Knowledge Summary</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item active" href="/algorithm/summary/complexity">复杂度与简单排序</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#认识时间复杂度">认识时间复杂度</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#空间复杂度">空间复杂度</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#位运算">位运算</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#面试题练手">面试题练手</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#选择排序">选择排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#冒泡排序">冒泡排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#插入排序">插入排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#二分法">二分法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#对数器">对数器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#递归行为与其时间复杂度估算">递归行为与其时间复杂度估算</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/algorithm/summary/merge">N·log(N) 的排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/algorithm/summary/stack">堆 &amp; 栈</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h2 id="认识时间复杂度" tabindex="-1">认识时间复杂度 <a class="header-anchor" href="#认识时间复杂度" aria-hidden="true">#</a></h2><p>常数时间操作</p><p>常数操作：一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作</p><p>常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）或位运算（<code>&amp;</code>、<code>|</code>、<code>~</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>）等</p><p><strong><code>在描述时间复杂度的表达式中，只要最高阶项，不要低阶项及高阶项的系数，即为该算法的时间复杂度</code></strong></p><p>比如我们初中接触过的一元二次方程的表达式：</p><div class="language-ts"><pre><code><span class="token comment">// 最终化简结果为</span>
aN<span class="token operator">^</span><span class="token number">2</span> <span class="token operator">+</span> bN <span class="token operator">+</span> c

<span class="token comment">// a, b, c 都是常数</span>
</code></pre></div><p>对这个栗子，我们使用 <code>O(N^2)</code> 来表示此算法的时间复杂度（读作：<code>Big O N 的平方</code>）</p><p>评价一个算法流程的好坏，先看时间复杂度的指标（<code>O(N^2)</code> 与 <code>O(N)</code> 比较），然后再分析不同数据样本下的实际运行时间（如两个算法分析得到的时间复杂度均为 <code>O(N)</code> 时，就需要实际运行结果来区分了）</p><h2 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-hidden="true">#</a></h2><p>与上面的意思一致，假如我们只需要有限的几个变量需要申请存储空间，与样本数据量无关时，我们称其空间复杂度为 <code>O(1)</code></p><p>若类似需要额外开辟跟样本数据一样大小的内存空间来实现算法功能，我们则称其空间复杂度为 <code>O(N)</code></p><h2 id="位运算" tabindex="-1">位运算 <a class="header-anchor" href="#位运算" aria-hidden="true">#</a></h2><p>既然上面提到了位运算，这里就简单讲讲吧：</p><ul><li><code>&amp;</code>：（<code>与</code>）两个位都为 1 时，结果才为 1，其余为 0</li><li><code>|</code>：（<code>或</code>）两个位都为 0 时，结果才为 0，其余为 1</li><li><code>~</code>：（<code>非</code>）取反，0 变 1，1 变 0</li><li><code>^</code>：（<code>异或</code>）两个位相同为 1（同为 0 或同为 1），不同则为 0（<code>无进位相加</code>）</li><li><code>&lt;&lt;</code>：各二进位全部左移若干位，高位丢弃，低位补 0</li><li><code>&gt;&gt;</code>：各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移）</li></ul><div class="language-ts"><pre><code><span class="token number">10</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span>

<span class="token comment">// 10 转换为二进制数为：1010，&lt;&lt; 1 表示左移一位</span>
<span class="token comment">// 即变为：10100，转换为十进制即为：20</span>
<span class="token comment">// 同样可以把左移看作以下公式：a * (2 ^ b)</span>
<span class="token comment">// 10 &lt;&lt; 1 = 10 * (2 ^ 1) = 20</span>

<span class="token number">11</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span> <span class="token comment">// 10 &gt;&gt; 1 的结果同样是 5</span>

<span class="token comment">// 11 转换为二进制数为：1011，&gt;&gt; 1 表示右移一位，</span>
<span class="token comment">// 并去除多余的右边，即变为：101，转换为十进制即为：5</span>
<span class="token comment">// 同样可以把右移看作以下公式：~~(a / (2 ^ b))</span>
<span class="token comment">// 11 &gt;&gt; 1 = ~~(11 / (2 ^ 1)) = 5</span>
</code></pre></div><h2 id="面试题练手" tabindex="-1">面试题练手 <a class="header-anchor" href="#面试题练手" aria-hidden="true">#</a></h2><blockquote><p>在一个数组（<code>arr: number[]</code>）中，<br><code>问题1</code>：已知其中一种数出现了奇数次，其他数出现了偶数次，求这个出现奇数次的数是啥？<br><code>问题2</code>：已知其中两种数出现了奇数次，其他数出现了偶数次，求这两个出现奇数次的数是啥？<br> 要求：时间复杂度为 <code>O(N)</code>，空间复杂度为 <code>O(1)</code></p></blockquote><div class="language-ts"><pre><code><span class="token comment">// 有上面的铺垫，我们可以知道问题1很简单，</span>
<span class="token comment">// 直接将数组中的数全部一起进行 异或运算，最后的结果就是这个数</span>
<span class="token keyword">function</span> <span class="token function">resolveOne</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr <span class="token operator">||</span> <span class="token operator">!</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">||</span> arr<span class="token operator">?.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The array is of the wrong type or
      the array is empty!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> eor <span class="token operator">=</span> <span class="token number">0</span>
  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    eor <span class="token operator">^=</span> item
    <span class="token comment">// 上面是下面的简写语法（应该都看得懂）</span>
    <span class="token comment">// eor = eor ^ item</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> eor
<span class="token punctuation">}</span>
</code></pre></div><div class="language-ts"><pre><code><span class="token comment">// 问题2，我们需要借助无进位相加的思想来方便理解</span>
<span class="token comment">// 转换为二进制来看时，异或运算计算时，只看对应位上 1 的个数有关</span>
<span class="token comment">// 这一位上出现奇数个 1，最后结果这位上就是 1，否则为 0</span>
<span class="token keyword">function</span> <span class="token function">resolveTwo</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr <span class="token operator">||</span> <span class="token operator">!</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">||</span> arr<span class="token operator">?.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The array is of the wrong type or the array is empty!</span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> eor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> onlyOne <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment">// 首先，还是得像问题1一样全部进行异或运算</span>
  <span class="token comment">// 得到这两个出现奇数次的数（假设为 a, b）的异或结果</span>
  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cur <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    eor <span class="token operator">^=</span> cur
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 此时得到的 eor = a ^ b</span>
  <span class="token comment">// 且 eor !== 0</span>
  <span class="token comment">// 那么在转换为二进制时，eor 必然有一个位置上的值为 1</span>

  <span class="token comment">// 那么 a, b 两数在这一位上必然是不同的，我们就能得到其中一个</span>

  <span class="token comment">// 提取出 eor 二进制数最右的 1</span>
  <span class="token keyword">let</span> rightOne <span class="token operator">=</span> eor <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>eor <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token comment">// 我们不妨假设 eor 为：100101100</span>
  <span class="token comment">// 那 rightOne 为：100101100 &amp; (011010011 + 1) = 0000000100</span>
  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cur <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 括号别丢，否则运算顺序错误会导致结果异常</span>
    <span class="token comment">// rightOne 仅为最右侧数为 1（二进制）</span>
    <span class="token comment">// 两个奇数次的数在这一位上：一个为 0，另一个数一定为 1</span>
    <span class="token comment">// 由 &amp; 操作特性我们得到结果为 0 的数一定是其中一个出现奇数次的数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur <span class="token operator">&amp;</span> rightOne<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 得到 a 或者 b 其中一个</span>
      onlyOne <span class="token operator">^=</span> cur
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 得到 a 或者 b 的另一个</span>
  eor <span class="token operator">^=</span> onlyOne
  <span class="token keyword">return</span> <span class="token punctuation">[</span>eor<span class="token punctuation">,</span> onlyOne<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="选择排序" tabindex="-1">选择排序 <a class="header-anchor" href="#选择排序" aria-hidden="true">#</a></h2><p>先简单理解一下思路吧：</p><div class="language-js"><pre><code><span class="token comment">// 比如说有一个无序数组，我们需要实现升序排列</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>

<span class="token comment">// 简单选择排序的思路就是，从左往右扫（右往左也行）</span>
<span class="token comment">// 找到最小的值，将它放到最左侧记录到的最小值位置</span>

<span class="token comment">// 简单说明如下：</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>
 ↑  ↑
 i  j

i<span class="token operator">:</span> 记录当前最小值索引
j<span class="token operator">:</span> 从 i 的下一位开始依次往后扫到数组结束，找到
   比当前 i 位置上的值小的值，进行交换
</code></pre></div><p>示例实现代码如下：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr <span class="token operator">||</span> arr<span class="token operator">?.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span>

  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length
  <span class="token comment">// i 从 0 → N-1</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// j 从 i+1 → N</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// j 位置上的小</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 两数交换</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;after sort: &#39;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 交换 arr 数组中 i，j 位置上的数</span>
<span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> j<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
  arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp
<span class="token punctuation">}</span>
</code></pre></div><p>从上面的示例代码，我们看到需要两层 <code>for</code> 循环，从时间复杂度上分析需要 <code>O(N^2)</code> （常数操作为 等差数列 求和），空间复杂度为 <code>O(1)</code></p><h2 id="冒泡排序" tabindex="-1">冒泡排序 <a class="header-anchor" href="#冒泡排序" aria-hidden="true">#</a></h2><p>简单说明：</p><div class="language-ts"><pre><code><span class="token comment">// 还是上面的示例无序数组，依旧升序排</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>

<span class="token comment">// 依次比较索引位置上的数</span>
<span class="token comment">// 1. 0 与 1 位置上的数比较，大的往后移</span>
<span class="token comment">// 2. 1 与 2 位置上的数比较，大的往后移</span>
<span class="token comment">// 3. 2 与 3 位置上的数比较，大的往后移</span>
<span class="token comment">// 4. 3 与 4 位置上的数比较，大的往后移</span>
<span class="token comment">// 依次进行比较（效果上来看就是，大的数会逐渐往后冒，直到排好序）</span>
</code></pre></div><p>示例实现代码如下：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr <span class="token operator">||</span> arr<span class="token operator">?.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span>

  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length
  <span class="token comment">// i 从 N → 1</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// j 从 0 → i</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// j 位置与 j+1 位置上的值比较，大的后移</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;after sort: &#39;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 交换 arr 数组中 i，j 位置上的数</span>
<span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> j<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
  arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
  arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
  <span class="token comment">// 解构语法</span>
  <span class="token comment">// [arr[i], arr[j]] = [arr[j], arr[i]]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面的示例代码，我们看到还是需要两层 <code>for</code> 循环，从时间复杂度上分析需要 <code>O(N^2)</code>，空间复杂度为 <code>O(1)</code></p><p>另外，可能你会注意到这里的 <code>swap</code> 方法好像有点 <strong>黑魔法</strong> 的意思！！！</p><p>这里也就是巧用了 <code>异或运算</code>（<code>^</code>）的性质达到了两数交换的效果</p><p>我们可能在学校里学习过异或运算：即 <code>相同为 0，不同为 1</code>，举个栗子：</p><div class="language-ts"><pre><code><span class="token comment">// 二进制数进行异或运算</span>
<span class="token number">01001001</span> <span class="token operator">^</span> <span class="token number">11010101</span>

<span class="token comment">// 我们写得好看一点就是：</span>
  <span class="token number">01001001</span>
<span class="token operator">^</span> <span class="token number">11010101</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
  <span class="token number">10011100</span>
</code></pre></div><p>其实按另一种更简单的理解就是 <strong><code>无进位相加</code></strong></p><p>但它还有一些性质：</p><blockquote><ol><li>0 与任何数异或，结果都是这个数：<code>0 ^ N = N</code></li><li>对于任意一个数 N 与它自己异或（包括六亲不认的 <code>NaN</code>），结果为 0：<code>N ^ N = 0</code></li><li>异或运算满足数学的 <code>交换律</code> 和 <code>结合律</code>：<code>a ^ b ^ c ^ d = a ^ (b ^ d) ^ c</code></li></ol></blockquote><p>由上面这些性质描述，我们解释一下上面的 黑魔法 <code>swap</code> 方法</p><div class="language-ts"><pre><code><span class="token comment">// 我们假设</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> 甲
<span class="token keyword">let</span> b <span class="token operator">=</span> 乙

<span class="token comment">// 跑这三行代码，a, b 的值互换</span>
<span class="token comment">// 这里我们带入值并运用上面的性质就一目了然了</span>
a <span class="token operator">=</span> a <span class="token operator">^</span> b  <span class="token comment">// a = 甲 ^ 乙</span>
b <span class="token operator">=</span> a <span class="token operator">^</span> b  <span class="token comment">// b = (甲 ^ 乙) ^ 乙 → b = 甲</span>
a <span class="token operator">=</span> a <span class="token operator">^</span> b  <span class="token comment">// a = (甲 ^ 乙) ^ (甲 ^ 乙 ^ 乙) → a = 乙</span>
</code></pre></div><p><strong>注意：</strong> 上面的 <code>a</code>，<code>b</code> 必须得是内存中两块不同的区域（值可以相同，但内存不能是同一块，否则会把它抹为 0）</p><h2 id="插入排序" tabindex="-1">插入排序 <a class="header-anchor" href="#插入排序" aria-hidden="true">#</a></h2><p>时间复杂度 <code>O(N^2)</code>（算法流程按最差情况来估计时间复杂度），空间复杂度 <code>O(1)</code></p><p>与数据状况有关，会优于 <code>冒泡排序</code> 与 <code>选择排序</code>（最好情况是 <code>O(N)</code>，最差是 <code>O(N^2)</code>）</p><blockquote><p>思路：</p><ol><li>索引从 0 到 n - 1，依次将第 n - 1 位的数依次与前一个数比较，小于前一个数，则交换</li><li>交换后，记载索引位前移一位（此时为：n-2），再将它与前一个比较，依次类推</li><li>则依次排列：0～1 索引位，0～2 索引位，0～3 索引位... 直到 0～n-1 上有序则结束</li></ol></blockquote><div class="language-ts"><pre><code><span class="token comment">// 实现</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>

<span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr <span class="token operator">||</span> <span class="token operator">!</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">||</span> arr<span class="token operator">?.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The array is of the wrong type or the array is empty!</span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 此方法见上面的实现</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 或者这样：</span>
    <span class="token comment">// for (let j = i - 1; j &gt;= 0; j--) {</span>
    <span class="token comment">//   if (arr[j] &gt; arr[j + 1]) {</span>
    <span class="token comment">//      swap(arr, j, j + 1)</span>
    <span class="token comment">//   }</span>
    <span class="token comment">// }</span>
  <span class="token punctuation">}</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;after sort: &#39;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="二分法" tabindex="-1">二分法 <a class="header-anchor" href="#二分法" aria-hidden="true">#</a></h2><p>在一个 <strong>有序</strong> 数组中，查找某个数是否存在，普通遍历时间复杂度为 <code>O(N)</code>，二分法的时间复杂度为 <code>O(logN)</code></p><p>二分法：每次对数组中的数据进行对半拆分，比较要查找的这个数与中间数（对半分的位置数）的大小，则可在剩下的一半数据中继续此操作，找到则返回 <code>true</code>（可能无需二分完全结束）</p><blockquote><p>对于二分法极小几率存在的求中间点索引计算，常规计算为：<br><code>~~((leftIdx + rightIdx) / 2)</code><br> 极小几率存在越界的问题（比如 <code>rightIdx</code> 为临界值，<code>(leftIdx + rightIdx)</code> 刚好超过最大值）， 那么我们可以换一种求值方案：<br><code>~~(leftIdx + (rightIdx - leftIdx) / 2)</code><br> 另外再进一步可以写为：<code>leftIdx + ((rightIdx - leftIdx) &gt;&gt; 1)</code></p></blockquote><p><strong>变式：</strong></p><ol><li>在一个有序数组中，查找 <code>&gt;= 某个数</code> 最左侧的位置（需要完全二分结束才能判定）</li><li><code>局部最小值</code> 问题</li></ol><blockquote><p>某个 <code>无序数组</code> 中，相邻的数一定 <strong><code>不相等</code></strong>，当存在 <code>N</code> 位置上的数小于 <code>N-1</code> 和 <code>N+1</code> 位置上的数时，那么这个第 <code>N</code> 位上的数即为我们要找的局部最小数，要求时间复杂度小于 <code>O(N)</code></p></blockquote><div class="language-js"><pre><code>思路：
<span class="token number">1.</span> 首先看 arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>、arr<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> 的值与其相邻数的比较结果，
   若存在 arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 或 arr<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> 的数小，则直接返回这其中一个即可
<span class="token number">2.</span> 若二者均大于相邻数（即：arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>），
   那么 <span class="token number">0</span>～<span class="token constant">N</span><span class="token operator">-</span><span class="token number">1</span> 范围内必定存在一个拐点（也就是局部最小值）
<span class="token number">3.</span> 根据这点，我们开始二分查找（记中间数拆分点索引为 m，比较
   arr<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>）；判断 <span class="token number">0</span>～m 或者 m～n<span class="token operator">-</span><span class="token number">1</span> 区间上的情况
   若与第 <span class="token number">2</span> 步一样，则继续二分
</code></pre></div><p>算法优化思路：<code>数据状况特殊</code> or <code>求解的问题特殊</code></p><h2 id="对数器" tabindex="-1">对数器 <a class="header-anchor" href="#对数器" aria-hidden="true">#</a></h2><blockquote><p>有一个你想要测的方法 a</p><ol><li>实现一个绝对正确但是复杂度不好的方法 b</li><li>实现一个随机样本产生器</li><li>实现比对的方法</li><li>把方法 a 和方法 b 比对很多次来验证方法 a 是否正确</li><li>如果有一个样本使得比对出错，打印样本分析是哪个方法出错，当样本数量很多时比对测试依然正确，可以确定方法 a 已经正确</li></ol></blockquote><p>如下示例所示：</p><div class="language-ts"><pre><code><span class="token comment">// 比如说你用 插入排序 实现的方法 insertSort 是我们说的方法 a</span>
<span class="token comment">// Array.prototype.sort 为 js 内部实现的排序算法，就是我们说的算法 b</span>
<span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 插入排序实现代码</span>
<span class="token punctuation">}</span>

<span class="token comment">// 得到 [min, max] 区间上的随机整数</span>
<span class="token keyword">function</span> <span class="token function">getRamdomInteger</span><span class="token punctuation">(</span>min<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> max<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 得到随机长度的随机数</span>
<span class="token keyword">function</span> <span class="token function">generateRandomArr</span><span class="token punctuation">(</span>
  maxLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  minValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  maxValue <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>maxLength<span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getRamdomInteger</span><span class="token punctuation">(</span>minValue<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">testFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> testTimes <span class="token operator">=</span> <span class="token number">500000</span>
  <span class="token keyword">const</span> maxLength <span class="token operator">=</span> <span class="token number">100</span>
  <span class="token keyword">const</span> minValue <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">100</span>
  <span class="token keyword">const</span> maxValue <span class="token operator">=</span> <span class="token number">100</span>
  <span class="token keyword">let</span> succeed <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token generic-function"><span class="token function">i</span> <span class="token generic class-name"><span class="token operator">&lt;</span> testTimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> arr1 <span class="token operator">=</span> <span class="token function">generateRandomArr</span><span class="token punctuation">(</span>maxLength<span class="token punctuation">,</span> minValue<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span>
    <span class="token comment">// 这里直接用扩展运算符复制一份（这里只是一维数组）</span>
    <span class="token keyword">const</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr1<span class="token punctuation">]</span>
    <span class="token function">insertSort</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span> <span class="token comment">// 插入排序 arr1，假设是升序排序</span>
    arr2<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span></span> <span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 升序</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEqual</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      succeed <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>succeed <span class="token operator">?</span> <span class="token string">&#39;Good job!&#39;</span> <span class="token operator">:</span> <span class="token string">&#39;Looks like something wrong~~&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isEqual</span><span class="token punctuation">(</span>originArr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> targetArr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 简便比较两个数组排序结果是否一致，直接转成字符串比较就好</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>originArr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;,&#39;</span><span class="token punctuation">)</span> <span class="token operator">===</span> targetArr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;,&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">testFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 执行看结果如何</span>
</code></pre></div><h2 id="递归行为与其时间复杂度估算" tabindex="-1">递归行为与其时间复杂度估算 <a class="header-anchor" href="#递归行为与其时间复杂度估算" aria-hidden="true">#</a></h2><p>举个 🌰：我们有一个数组，我们要得到其中的最大数，当然实现方案有很多，单纯遍历比较就可以，我们这里用一个递归方案实现一下：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">getMaxNum</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">process</span><span class="token punctuation">(</span>
  arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  l<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  r<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 就一个数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">===</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> midIdx <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 看上面二分法</span>
  <span class="token comment">// 还是会遍历到每个数，这个数组并不一定是有序的</span>
  <span class="token keyword">const</span> leftMax <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> midIdx<span class="token punctuation">)</span>
  <span class="token keyword">const</span> rightMax <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> midIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">,</span> rightMax<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是递归操作十分容易导致调用栈溢出的问题，所以得想办法避免使用递归，或者使用 <code>ES6 尾调用优化方案</code>（比如：<a href="/knowledge/study/algorithm.html#_4-斐波那契数列">斐波那契数列 方案四 🔗</a>)</p><p>尾调用优化需要满足下列条件：</p><blockquote><ul><li>必须在 <code>严格模式</code> 下：<code>&#39;use strict&#39;</code></li><li>尾调用 <code>不访问</code> 当前栈帧的变量（也就是说函数不是一个闭包）</li><li>在函数内部，尾调用是最后一条语句</li><li>尾调用的结果作为 <code>函数值</code>返回</li></ul></blockquote><p>递归算法的时间复杂度问题比较麻烦，从而出现了 <code>Master 公式</code> 来进行估算</p><div class="language-js"><pre><code><span class="token constant">T</span><span class="token punctuation">(</span><span class="token constant">N</span><span class="token punctuation">)</span> <span class="token operator">=</span> a<span class="token operator">*</span><span class="token constant">T</span><span class="token punctuation">(</span><span class="token constant">N</span><span class="token operator">/</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">O</span><span class="token punctuation">(</span><span class="token constant">N</span><span class="token operator">^</span>d<span class="token punctuation">)</span>
</code></pre></div><blockquote><p>解释：<br><code>N</code> 表示 <code>问题的规模</code>，<code>a</code> 表示 <code>递归的次数</code>，也就是生成的子问题数，<br><code>N/b</code> 表示 <code>子问题的规模</code>， <code>O(N^d)</code> 表示除了递归操作以外其余操作的复杂度</p></blockquote><p>结论：</p><p><img src="/images/masterResult.png" alt="公式结论"></p><p><strong>注意⚠️：不管分成几部分，子问题规模必须等分</strong></p></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><a class="link" href="https://github.com/suressk/edit/deploy/docs/algorithm/summary/complexity.md" target="_blank" rel="noopener noreferrer" data-v-1ed99556>Edit this page on GitHub <svg class="icon outbound icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-1ed99556><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="updated" data-v-fb8d84c6><p class="last-updated" data-v-fb8d84c6 data-v-5797b537><span class="prefix" data-v-5797b537>Last Updated:</span><span class="datetime" data-v-5797b537></span></p></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><!----></div><div class="next" data-v-38ede35f><a class="link" href="/algorithm/summary/merge" data-v-38ede35f><span class="text" data-v-38ede35f>N·log(N) 的排序</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"algorithm_index.md\":\"e9fd5986\",\"algorithm_summary_complexity.md\":\"d85a1d14\",\"algorithm_summary_merge.md\":\"dd2f7be3\",\"algorithm_summary_stack.md\":\"a6961cf4\",\"index.md\":\"4abf28d5\",\"interview_index.md\":\"989b976b\",\"interview_summary_actual.md\":\"69045102\",\"interview_summary_basis.md\":\"703d5afc\",\"interview_summary_index.md\":\"9e205d84\",\"interview_summary_internet.md\":\"57762282\",\"interview_summary_optimization.md\":\"47633787\",\"interview_summary_strands.md\":\"a0c1029c\",\"knowledge_engineering_compare.md\":\"01e6dbb7\",\"knowledge_engineering_hotupdate.md\":\"340c8f32\",\"knowledge_engineering_lint.md\":\"7e34550b\",\"knowledge_engineering_loaderandplugin.md\":\"74511eee\",\"knowledge_engineering_tapable.md\":\"78fcf899\",\"knowledge_engineering_webpack.md\":\"bb8ee6aa\",\"knowledge_index.md\":\"09a7956f\",\"knowledge_react_fiber.md\":\"74f1d84d\",\"knowledge_react_index.md\":\"6f6372f6\",\"knowledge_study_algorithm.md\":\"75ecada9\",\"knowledge_study_jseventloop.md\":\"ffe3345b\",\"knowledge_study_promise.md\":\"7c7b147d\",\"knowledge_study_vuenexttick.md\":\"244c1996\",\"knowledge_vite_esbuild.md\":\"032a4384\",\"knowledge_vite_index.md\":\"16222dcb\",\"knowledge_vite_plugin.md\":\"76b64563\",\"knowledge_vite_resolveconfig.md\":\"370aa044\",\"knowledge_vite_vitejs.md\":\"0956746a\",\"mood_autumn.md\":\"b5a1e6ae\",\"mood_chinaintheclassics.md\":\"d0e29f8c\",\"mood_dragonboatfestival.md\":\"a4adaa88\",\"mood_fate.md\":\"ffcecf90\",\"mood_feels.md\":\"014fbdd7\",\"mood_index.md\":\"952f61ba\",\"mood_loneliness.md\":\"b149e24a\",\"mood_spring.md\":\"813caf57\",\"mood_wind.md\":\"67b6a485\",\"mood_yearend.md\":\"0b07f5b7\"}")</script>
    <script type="module" async src="/assets/app.108cc30f.js"></script>
    
  </body>
</html>