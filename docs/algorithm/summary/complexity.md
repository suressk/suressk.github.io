---
title: 认识复杂度与简单排序
---

### 认识时间复杂度

常数时间操作

常数操作：一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作

常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算（`+`、`-`、`*`、`/`）或位运算（`&`、`|`、`~`、`^`、`<<`、`>>`）等

**`在描述时间复杂度的表达式中，只要最高阶项，不要低阶项及高阶项的系数，即为该算法的时间复杂度`**

比如我们初中接触过的一元二次方程的表达式：

```ts
// 最终化简结果为
aN^2 + bN + c

// a, b, c 都是常数
```

对这个栗子，我们使用 `O(N^2)` 来表示此算法的时间复杂度（读作：`Big O N 的平方`）

评价一个算法流程的好坏，先看时间复杂度的指标（`O(N^2)` 与 `O(N)` 比较），然后再分析不同数据样本下的实际运行时间（如两个算法分析得到的时间复杂度均为 `O(N)` 时，就需要实际运行结果来区分了）

### 空间复杂度

与上面的意思一致，假如我们只需要有限的几个变量需要申请存储空间，与样本数据量无关时，我们称其空间复杂度为 `O(1)`

若类似需要额外开辟跟样本数据一样大小的内存空间来实现算法功能，我们则称其空间复杂度为 `O(N)`

### 位运算

既然上面提到了位运算，这里就简单讲讲吧：

- `&`：两个位都为 1 时，结果才为 1，其余为 0
- `|`：两个位都为 0 时，结果才为 0，其余为 1
- `~`：取反，0 变 1，1 变 0
- `^`：两个位相同为 1（同为 0 或同为 1），不同则为 0
- `<<`：各二进位全部左移若干位，高位丢弃，低位补 0
- `>>`：各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移）

```ts
10 << 1

// 10 转换为二进制数为：1010，<< 1 表示左移一位
// 即变为：10100，转换为十进制即为：20
// 同样可以把左移看作以下公式：a * (2 ^ b)
// 10 << 1 = 10 * (2 ^ 1) = 20

11 >> 1 // 10 >> 1 的结果同样是 5

// 11 转换为二进制数为：1011，>> 1 表示右移一位，
// 并去除多余的右边，即变为：101，转换为十进制即为：5
// 同样可以把右移看作以下公式：~~(a / (2 ^ b))
// 11 >> 1 = ~~(11 / (2 ^ 1)) = 5
```

### 选择排序

先简单理解一下思路吧：

```js
// 比如说有一个无序数组，我们需要实现升序排列
[4, 2, 6, 3, 8, 9, 0, 1, 5, 7]

// 简单选择排序的思路就是，从左往右扫（右往左也行）
// 找到最小的值，将它放到最左侧记录到的最小值位置

// 简单说明如下：
[4, 2, 6, 3, 8, 9, 0, 1, 5, 7]
 ↑  ↑
 i  j

i：记录当前最小值索引
j：从 i 的下一位开始依次往后扫到数组结束，找到
   比当前 i 位置上的值小的值，进行交换
```

示例实现代码如下：

```ts
function selectSort(arr: number[]) {
  if (!arr || arr?.length < 2) return

  const len = arr.length
  // i 从 0 → N-1
  for (let i = 0; i < len - 1; i++) {
    // j 从 i+1 → N
    for (let j = i + 1; j < len; j++) {
      // j 位置上的小
      if (arr[j] < arr[i]) {
        // 两数交换
        swap(arr, i, j)
      }
    }
  }
  console.log('after sort: ', arr)
}

// 交换 arr 数组中 i，j 位置上的数
function swap(arr: number[], i: number, j: number) {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}
```

从上面的示例代码，我们看到需要两层 `for` 循环，从时间复杂度上分析需要 `O(N^2)` （常数操作为 等差数列 求和），空间复杂度为 `O(1)`

### 冒泡排序

简单说明：

```ts
// 还是上面的示例无序数组，依旧升序排
[4, 2, 6, 3, 8, 9, 0, 1, 5, 7]

// 依次比较索引位置上的数
// 1. 0 与 1 位置上的数比较，大的往后移
// 2. 1 与 2 位置上的数比较，大的往后移
// 3. 2 与 3 位置上的数比较，大的往后移
// 4. 3 与 4 位置上的数比较，大的往后移
// 依次进行比较（效果上来看就是，大的数会逐渐往后冒，直到排好序）
```

示例实现代码如下：

```ts
function bubbleSort(arr: number[]) {
  if (!arr || arr?.length < 2) return

  const len = arr.length
  // i 从 N → 1
  for (let i = len - 1; i > 0; i--) {
    // j 从 0 → i
    for (let j = 0; j < i; j++) {
      // j 位置与 j+1 位置上的值比较，大的后移
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
      }
    }
  }
  console.log('after sort: ', arr)
}

// 交换 arr 数组中 i，j 位置上的数
function swap(arr: number[], i: number, j: number) {
  arr[i] = arr[i] ^ arr[j]
  arr[j] = arr[i] ^ arr[j]
  arr[i] = arr[i] ^ arr[j]
  // 解构语法
  // [arr[i], arr[j]] = [arr[j], arr[i]]
}
```

从上面的示例代码，我们看到还是需要两层 `for` 循环，从时间复杂度上分析需要 `O(N^2)`，空间复杂度为 `O(1)`

另外，可能你会注意到这里的 `swap` 方法好像有点 **黑魔法** 的意思！！！

这里也就是巧用了 `异或运算`（`^`）的性质达到了两数交换的效果

我们可能在学校里学习过异或运算：即 `相同为 0，不同为 1`，举个栗子：

```ts
// 二进制数进行异或运算
01001001 ^ 11010101

// 我们写得好一点就是：
  01001001
^ 11010101
-----------
  10011100
```

其实按另一种更简单的理解就是 **`无进位相加`**

但它还有一些性质：

> 1. 0 与任何数异或，结果都是这个数：`0 ^ N = N`
> 2. 对于任意一个数 N 与它自己异或（包括六亲不认的 `NaN`），结果为 0：`N ^ N = 0`
> 3. 异或运算满足数学的 `交换律` 和 `结合律`：`a ^ b ^ c ^ d = a ^ (b ^ d) ^ c`

由上面这些性质描述，我们解释一下上面的 黑魔法 `swap` 方法

```ts
// 我们假设
let a = 甲
let b = 乙

// 跑这三行代码，a, b 的值互换
// 这里我们带入值并运用上面的性质就一目了然了
a = a ^ b  // a = 甲 ^ 乙
b = a ^ b  // b = (甲 ^ 乙) ^ 乙 → b = 甲
a = a ^ b  // a = (甲 ^ 乙) ^ (甲 ^ 乙 ^ 乙) → a = 乙
```

**注意：** 上面的 `a`，`b` 必须得是内存中两块不同的区域（值可以相同，但内存不能是同一块，否则会把它抹为 0）

### 面试题练手

> 在一个数组（`arr: number[]`）中，<br/>
> `问题1`：已知其中一种数出现了奇数次，其他数出现了偶数次，求这个出现奇数次的数是啥？<br/>
> `问题2`：已知其中两种数出现了奇数次，其他数出现了偶数次，求这两个出现奇数次的数是啥？<br/>
> 要求：时间复杂度为 `O(N)`，空间复杂度为 `O(1)`

```ts
// 有上面的铺垫，我们可以知道问题1很简单，
// 直接将数组中的数全部一起进行 异或运算，最后的结果就是这个数
function resolveOne(arr: number[]) {
  if (!arr || !Array.isArray(arr) || arr?.length = 0) {
    throw new Error(`The array is of the wrong type or
      the array is empty!`)
  }
  let eor = 0
  arr.forEach(item => {
    eor ^= item
    // 上面是下面的简写语法（应该都看得懂）
    // eor = eor ^ item
  })
  return eor
}
```

```ts
// 问题2，我们需要借助无进位相加的思想来方便理解
// 转换为二进制来看时，异或运算计算时，只看对应位上 1 的个数有关
// 这一位上出现奇数个 1，最后结果这位上就是 1，否则为 0
function resolveTwo(arr: number[]) {
  if (!arr || !Array.isArray(arr) || arr?.length = 0) {
    throw new Error(`The array is of the wrong type or
      the array is empty!`)
  }
  let eor = 0, onlyOne = 0
  // 首先，还是得像问题1一样全部进行异或运算
  // 得到这两个出现奇数次的数（假设为 a, b）的异或结果
  arr.forEach(cur => {
    eor ^= cur
  })
  // 此时得到的 eor = a ^ b
  // 且 eor !== 0
  // 那么在转换为二进制时，eor 必然有一个位置上的值为 1

  // 那么 a, b 两数在这一位上必然是不同的，我们就能得到其中一个

  // 提取出 eor 二进制数最右的 1
  let rightOne = eor & (~eor + 1)
  // 我们不妨假设 eor 为：100101100
  // 那 rightOne 为：100101100 & (011010011 + 1) = 0000000100
  arr.forEach(cur => {
    // 括号别丢，否则运算顺序错误会导致结果异常
    if ((cur & rightOne) === 0) {
      // 得到 a 或者 b 其中一个
      onlyOne ^= cur
    }
  })
  // 得到 a 或者 b 的另一个
  eor ^= onlyOne
  return [eor, onlyOne]
}
```