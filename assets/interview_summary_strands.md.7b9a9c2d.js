import{_ as e,c as o,o as c,b as d}from"./app.2c7d1395.js";const _=JSON.parse('{"title":"面试题分析（二）","description":"","frontmatter":{"title":"面试题分析（二）"},"headers":[{"level":2,"title":"1. webpack 与 rollup 的区别？webpack5 与 webpack4？","slug":"_1-webpack-与-rollup-的区别-webpack5-与-webpack4","link":"#_1-webpack-与-rollup-的区别-webpack5-与-webpack4","children":[]},{"level":2,"title":"2. composition-api 与 hooks 的异同点？","slug":"_2-composition-api-与-hooks-的异同点","link":"#_2-composition-api-与-hooks-的异同点","children":[]},{"level":2,"title":"3. vue 中的 jsx 与 react 的 jsx 区别？","slug":"_3-vue-中的-jsx-与-react-的-jsx-区别","link":"#_3-vue-中的-jsx-与-react-的-jsx-区别","children":[]},{"level":2,"title":"4. 说说 XSS 攻击与防范？","slug":"_4-说说-xss-攻击与防范","link":"#_4-说说-xss-攻击与防范","children":[]},{"level":2,"title":"5. DNS 劫持","slug":"_5-dns-劫持","link":"#_5-dns-劫持","children":[]},{"level":2,"title":"6. 说说 cors 跨站脚本攻击防范？","slug":"_6-说说-cors-跨站脚本攻击防范","link":"#_6-说说-cors-跨站脚本攻击防范","children":[]},{"level":2,"title":"7. 说说 CSRF 跨站请求伪造防范？","slug":"_7-说说-csrf-跨站请求伪造防范","link":"#_7-说说-csrf-跨站请求伪造防范","children":[]},{"level":2,"title":"8. devOps（如 jenkins 等）","slug":"_8-devops-如-jenkins-等","link":"#_8-devops-如-jenkins-等","children":[]},{"level":2,"title":"9. 测试框架（jest）","slug":"_9-测试框架-jest","link":"#_9-测试框架-jest","children":[]},{"level":2,"title":"10. 说一说 qiankun 的路由匹配原理","slug":"_10-说一说-qiankun-的路由匹配原理","link":"#_10-说一说-qiankun-的路由匹配原理","children":[]}],"relativePath":"interview/summary/strands.md"}'),i={name:"interview/summary/strands.md"},l=d('<h2 id="_1-webpack-与-rollup-的区别-webpack5-与-webpack4" tabindex="-1">1. webpack 与 rollup 的区别？webpack5 与 webpack4？ <a class="header-anchor" href="#_1-webpack-与-rollup-的区别-webpack5-与-webpack4" aria-hidden="true">#</a></h2><p>见 <a href="/knowledge/engineering/compare.html">打包工具对比 🔗</a></p><h2 id="_2-composition-api-与-hooks-的异同点" tabindex="-1">2. composition-api 与 hooks 的异同点？ <a class="header-anchor" href="#_2-composition-api-与-hooks-的异同点" aria-hidden="true">#</a></h2><p>react 对 hook 的定义是：</p><blockquote><p>它可以让你在不编写 class 的情况下，让你在函数组件里 “钩入” React state 及生命周期等特性的函数</p></blockquote><p>vue 的 composition-api（我们也可称为 <code>Vue Hooks</code>），它受到了 React Hooks 的启发，但也有些不同，规避了一些 react 的问题</p><p>在 hook 思想出来之前，针对业务上的逻辑复用功能：vue 采用 <code>mixins</code> 方案，react 采用 <code>render props</code>、<code>高阶组件</code> 的方案处理</p><ul><li>mixins 与组件之前是隐式依赖，可能会产生冲突（比如我们定义的方法名、数据名重名的情况）</li><li>高阶组件和 <code>render props</code> 容易导致组件嵌套层次过深，增大复杂度和维护成本</li></ul><p>不同点：</p><ol><li><p>React Hooks 是基于 <code>链表</code> 实现的，不能在循环内部、条件语句中或嵌套函数里调用 Hooks；Vue Hooks 定义在 <code>setup</code> 函数中，由于它数据的响应式是基于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noreferrer">Proxy</a> 实现的，只要更改数据就会触发对应的依赖函数执行更新操作，所以避开了 react 可能遇到的性能问题</p></li><li><p>代码执行时机：React hooks 在组件每次渲染时都会运行；Vue Hooks 定义在 <code>setup()</code> 函数中，它会早于 <code>beforeCreate</code> 和 <code>created</code> 生命周期函数，且仅执行一次</p></li><li><p>React 使用 <code>useState</code> Hook 来声明数据，传入一个参数作为数据初始值（只会在初次运行这个函数时使用这个值进行初始化）；Vue 中使用 <code>ref</code> 和 <code>reactive</code> 这两个函数来定义数据</p></li></ol><h2 id="_3-vue-中的-jsx-与-react-的-jsx-区别" tabindex="-1">3. vue 中的 jsx 与 react 的 jsx 区别？ <a class="header-anchor" href="#_3-vue-中的-jsx-与-react-的-jsx-区别" aria-hidden="true">#</a></h2><p>vue 组件使用 jsx 需要使用插件进行编译，react 组件中是默认支持的</p><p>vue template 与 react jsx 的区别：</p><p>vue 中提供一系列指令帮助我们构建页面</p><h2 id="_4-说说-xss-攻击与防范" tabindex="-1">4. 说说 XSS 攻击与防范？ <a class="header-anchor" href="#_4-说说-xss-攻击与防范" aria-hidden="true">#</a></h2><p><code>XSS</code> 攻击（<code>Cross-Site Scripting</code>，跨站脚本攻击），它是页面中被注入了恶意的代码</p><p>一般，XSS 攻击有下列注入方式：</p><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签</li><li>在标签的 href、src 等属性中，包含 <code>javascript:</code> 等可执行代码</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码</li><li>在 style 属性和标签中，包含类似 <code>background-image:url(&quot;javascript:...&quot;);</code> 的代码（新版本浏览器已经可以防范）</li><li>在 style 属性和标签中，包含类似 <code>expression(...)</code> 的 CSS 表达式代码（新版本浏览器已经可以防范）</li></ul><p>防范手段（可能并不全面）：</p><ul><li><p><code>输入过滤</code>，这也仅限于明确类型的用户输入，比如 <code>数字</code>、<code>URL</code>、<code>邮箱</code> 等内容进行必要的过滤处理</p></li><li><p><code>输入长度限制</code>，虽不能完全防止，但可以增加 XSS 攻击的难度</p></li><li><p><code>做纯前端渲染</code>，将数据与代码分隔开，对 HTML 做充分 <code>转义</code>（输出 HTML 时进行）</p></li><li><p>纯前端渲染方案中，尽量采用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute</code> 等 API，避免使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.document.write()</code> 等 API；在 vue/react 框架中，避免使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能；注意关注 DOM 内联事件或 <code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，js 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setImmediate()</code>、<code>setInterval()</code> 等 API 均能将 <strong>字符串</strong> 作为代码直接执行</p></li></ul><h2 id="_5-dns-劫持" tabindex="-1">5. DNS 劫持 <a class="header-anchor" href="#_5-dns-劫持" aria-hidden="true">#</a></h2><p>域名解析需要由专门的域名解析服务器来完成，<code>DNS</code> 就是进行域名解析的服务器（<code>Domain Name System</code> 或<code>Domain Name Service</code>）</p><p>在网络中，机器之间是通过 <code>ip</code> 地址互相访问与通信的，但是为了便于记忆，就可以为每个 <code>ip</code> 配置对应的 <code>域名</code>，然后我们直接通过访问域名的方式，由浏览器去进行 <code>DNS</code> 解析获取到对应的 <code>ip</code> 地址，达到访问目标的目的（这也是常规八股文 <a href="/interview/summary/index.html#_2-浏览器输入-url-发生了什么？"><code>浏览器输入 URL 发生了什么 🔗</code></a> 的第一步 <code>DNS 域名解析</code> 做的事情）</p><p><code>DNS 劫持</code> 又称为 <code>域名劫持</code>，它是指通过某些手段获得某些域名的解析控制权，在你访问某个域名时，给你返回错误的 <code>ip</code> 地址，结果就是网址无法访问或者假网址（比如攻击者搭建一个跟原网址 <code>长得一样</code> 的页面，你在这个网站的一切操作，比如登录的账号、密码等信息，可能都被其记录并发送到攻击者手里了）。<code>DNS 劫持</code> 并不是说 <code>黑掉了</code> 对方的网站，而是一种 <code>冒名顶替</code> 或 <code>无响应</code> 的攻击方式</p><p><strong>DNS 劫持方法：</strong></p><ul><li><p>利用 DNS 劫持进行 <a href="https://help.aliyun.com/document_detail/28401.html" target="_blank" rel="noreferrer"><code>DDoS</code> 攻击 🔗</a></p><blockquote><p>由于在 DNS 缓存未命中的情况下，会向 DNS 服务器发起递归查询，拿到映射结果后逐级缓存。假如在此过程中攻击者已知我们的 IP 地址，且攻击者拥有足够数量的 <code>肉鸡</code>，反复的进行如上操作，那么我们就会受到来自于 DNS 服务器的响应信息 DDoS 攻击（结果就是 <code>我们的网络被拖垮至发生中断</code>）</p></blockquote></li><li><p>DNS 缓存感染</p><blockquote><p>攻击者使用 DNS 请求，将数据放入一个具有漏洞的的 DNS 服务器的缓存当中，我们在进行 DNS 访问时拿到这些污染的缓存信息，从而将我们正常的域名访问 <code>导向访问攻击者设置的钓鱼 🎣 网站，或通过其他伪造手段获取用户账号密码信息等的攻击手段</code></p></blockquote></li><li><p>DNS 信息劫持</p><blockquote><p>假设攻击者如果通过监听客户端和 DNS 服务器的对话，在 DNS 服务器之前将虚假的响应交给用户，从而 <code>欺骗客户端去访问恶意的网站</code></p></blockquote></li><li><p>DNS 重定向</p><blockquote><p>攻击者将 DNS 名称查询重定向到恶意 DNS 服务器上，被劫持 <code>域名的解析就完全在攻击者的控制之下</code></p></blockquote></li><li><p>ARP 欺骗</p><blockquote><p>ARP 攻击就是通过伪造 IP 地址和 MAC 地址实现 ARP 欺骗，能够在网络中产生大量的 ARP 通信量使网络阻塞，<code>造成网络中断 或 中间人攻击</code></p></blockquote></li><li><p>本机劫持</p><blockquote><p>本机的计算机系统被木马或流氓软件感染后，DNS 缓存被修改导致域名访问异常。本机 DNS 劫持方式包括 <code>hosts 文件篡改</code>、<code>本机 DNS 劫持</code>、<code>SPI 链注入</code>、<code>BHO 插件</code> 等方式</p></blockquote></li></ul><p><strong>防止 DNS 劫持方法（网络层）：</strong></p><ul><li><p>准备多个域名，可能出现一个被攻击的情况下，能够有其他域名可以正常访问</p></li><li><p>手动修改路由器 <code>首选DNS</code> 和 <code>备用DNS</code> IP</p><blockquote><ul><li>地址栏输入 <code>192.168.0.1</code> / <code>192.168.1.1</code> 登录进入路由器管理界面</li><li>在 <code>DHCP服务器—DHCP</code> 服务中，填写 <code>主选DNS服务器</code> 为更可靠的 <code>114.114.114.114</code> 地址，<code>备用DNS服务器</code> 为 <code>8.8.8.8</code></li><li>隔段时间重新设置路由器登录密码</li></ul></blockquote></li></ul><h2 id="_6-说说-cors-跨站脚本攻击防范" tabindex="-1">6. 说说 cors 跨站脚本攻击防范？ <a class="header-anchor" href="#_6-说说-cors-跨站脚本攻击防范" aria-hidden="true">#</a></h2><p><code>CORS</code>：跨域资源共享（<code>Cross-origin resource sharing</code>），它使用额外的 <code>HTTP</code> 头来告诉浏览器让运行在一个 <code>origin</code> (<code>domain</code>) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源</p><p>cors 将请求分为两种：</p><ul><li><code>简单请求（simple request）</code></li><li><code>非简单请求（preflight request）</code>，会首先发送一个 <code>OPTIONS</code> 预检请求</li></ul><p><strong>简单请求</strong> 需要满足以下条件：</p><ul><li>请求的方法只能是 <code>GET</code>, <code>POST</code>, <code>HEAD</code> 的一种</li><li>请求的 <code>header</code> 的只能是 <code>Accept</code>，<code>Accept-Language</code>, <code>Content-Language</code>，<code>Content-Type</code> 这些字段，不能超出这些字段</li><li><code>Content-Type</code> 字段，只能是以下值： <ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul></li></ul><p>除此之外，均是非简单请求</p><p>非简单请求，先发出预检请求，检查当前请求是否符合服务器的 cors 配置，如果符合，则再发出真正的请求；不符合则直接返回跨域</p><blockquote><p>如果预检请求通过了，在一定时间内重复请求是不用再次发起预检请求</p></blockquote><h2 id="_7-说说-csrf-跨站请求伪造防范" tabindex="-1">7. 说说 CSRF 跨站请求伪造防范？ <a class="header-anchor" href="#_7-说说-csrf-跨站请求伪造防范" aria-hidden="true">#</a></h2><h2 id="_8-devops-如-jenkins-等" tabindex="-1">8. devOps（如 jenkins 等） <a class="header-anchor" href="#_8-devops-如-jenkins-等" aria-hidden="true">#</a></h2><h2 id="_9-测试框架-jest" tabindex="-1">9. 测试框架（jest） <a class="header-anchor" href="#_9-测试框架-jest" aria-hidden="true">#</a></h2><h2 id="_10-说一说-qiankun-的路由匹配原理" tabindex="-1">10. 说一说 <code>qiankun</code> 的路由匹配原理 <a class="header-anchor" href="#_10-说一说-qiankun-的路由匹配原理" aria-hidden="true">#</a></h2>',41),a=[l];function t(r,s,p,n,u,h){return c(),o("div",null,a)}const S=e(i,[["render",t]]);export{_ as __pageData,S as default};
