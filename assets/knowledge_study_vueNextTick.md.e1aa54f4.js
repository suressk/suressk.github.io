import{_ as s,o as n,c as a,b as e}from"./app.85987840.js";const C=JSON.parse('{"title":"vue nextTick","description":"","frontmatter":{"title":"vue nextTick"},"headers":[{"level":2,"title":"理解 MutationObserver","slug":"理解-mutationobserver","link":"#理解-mutationobserver","children":[]},{"level":2,"title":"Vue nextTick 实现原理","slug":"vue-nexttick-实现原理","link":"#vue-nexttick-实现原理","children":[]}],"relativePath":"knowledge/study/vueNextTick.md"}'),l={name:"knowledge/study/vueNextTick.md"},o=e(`<p>尽管 MVVM 框架并不推荐访问 DOM，但有时候确实会有这样的需求，免不了要进行 DOM 操作。而 nextTick 就提供了一个桥梁，确保我们操作的是更新后的 DOM，而能监听到 DOM 改动的 API 好像只有 HTML5 新增的 MutationObserver 了</p><h2 id="理解-mutationobserver" tabindex="-1">理解 MutationObserver <a class="header-anchor" href="#理解-mutationobserver" aria-hidden="true">#</a></h2><p>MutationObserver (<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noreferrer">MDN 参考</a>) 是 HTML5 新增的属性，用于监听 DOM 修改事件，能够监听到节点的属性、文本内容、子节点等的改动，基本用法如下：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// MutationObserver 构造函数，创建并返回一个新的 MutationObserver，它会在指定的DOM发生变化时被调用</span></span>
<span class="line"><span style="color:#676E95;">// 方法：</span></span>
<span class="line"><span style="color:#676E95;">// 1. disconnect()：阻止 MutationObserver 实例继续接收的通知，直到再次调用其observe()方法</span></span>
<span class="line"><span style="color:#676E95;">// 2. observe()：监听 DOM 元素，接收 DOM 元素更新的通知</span></span>
<span class="line"><span style="color:#676E95;">// 3. takeRecords()：从MutationObserver的通知队列中删除所有待处理的通知，并将它们返回到MutationRecord对象的新Array中</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> callback </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">mutationList</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">observer</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// DOM 更新后的回调函数</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">DOM has been changed</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// for(let mutation of mutationsList) {</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">//     mutation.type === &#39;childList&#39; =&gt; 子节点新增或移除</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">//     mutation.type === &#39;attributes&#39; =&gt; 目标节点属性变更 (mutation.attributeName：变化的属性名)</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// }</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> observer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MutationObserver</span><span style="color:#A6ACCD;">(callback)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> targetNode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">observeNode</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// 观察器的配置（需要观察什么变动）</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> config </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">attributes</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 监听 DOM 元素属性变化</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">childList</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 监听子列表变化</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">subtree</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 深层监听子孙及更深级子树变化</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">observer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">observe</span><span style="color:#A6ACCD;">(targetNode</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> config)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 监听目标节点的变化 (targetNode：目标 DOM 元素)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// observer.disconnect() // 取消监听</span></span>
<span class="line"></span></code></pre></div><h2 id="vue-nexttick-实现原理" tabindex="-1">Vue nextTick 实现原理 <a class="header-anchor" href="#vue-nexttick-实现原理" aria-hidden="true">#</a></h2><p>通过看这部分源码 (vue 2.6.14) 得知其实现方案：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">/**</span></span>
<span class="line"><span style="color:#676E95;">1. 声明一个数组 callbacks，收集需处理的回调函数</span></span>
<span class="line"><span style="color:#676E95;">2. 调用 nextTick 函数，将传入的回调函数用新函数容错处理包裹后，放进 callbacks 数组暂存</span></span>
<span class="line"><span style="color:#676E95;">3. 检查当前是否是 pending 状态，若为 false，则置为 true 并遍历执行 callbacks 中存放的函数</span></span>
<span class="line"><span style="color:#676E95;">4. 遍历调用的降级策略为：Promise =&gt; MutationObserver =&gt; setImmediate =&gt; setTimeout</span></span>
<span class="line"><span style="color:#676E95;">   - 优先判定是否支持 Promise 微任务方案，若支持，则将遍历 callbacks 数组执行的任务推入微任务队列</span></span>
<span class="line"><span style="color:#676E95;">   - 若不支持 Promise 且非 IE 浏览器，判定是否支持 MutationObserver API，若支持，则创建一个 TextNode 节点，</span></span>
<span class="line"><span style="color:#676E95;">     更改其节点值 0/1，触发 observer 的回调函数遍历 callbacks 数组执行(也是微任务)</span></span>
<span class="line"><span style="color:#676E95;">   - 若前两种都不支持，则使用宏任务 setImmediate 和 setTimeout 推入宏任务队列，遍历执行</span></span>
<span class="line"><span style="color:#676E95;">*/</span></span>
<span class="line"></span></code></pre></div><p>vue 通过事件队列的控制来达到访问更新后的 DOM <a href="https://juejin.cn/post/6844903590293684231#heading-2" target="_blank" rel="noreferrer">Link</a>，vue 进行 DOM 更新内部也是调用 nextTick 来做异步队列控制。而当我们自己调用 nextTick 的时候，它就在更新 DOM 的那个 microtask 后追加了我们自己的回调函数，从而确保我们的代码在 DOM 更新后执行，同时也避免了 setTimeout 可能存在的多次执行问题</p><p>总结其实现原理就是：</p><ol><li>vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调的先后执行</li><li>microtask 因为在事件循环中的优先级更高，能够保证微任务在一次事件循环前被执行完毕，之后再进行 UI 渲染</li><li>因为兼容性问题，所以 vue 做了降级处理：Promise =&gt; MutationObserver =&gt; setImmediate =&gt; setTimeout (vue 2.6.14)</li></ol>`,10),p=[o];function t(c,r,i,D,y,F){return n(),a("div",null,p)}const u=s(l,[["render",t]]);export{C as __pageData,u as default};
